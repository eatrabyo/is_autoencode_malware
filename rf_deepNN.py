import numpy as np
import random
import tensorflow as tf
import keras
import matplotlib.pyplot as plt
import wandb
from wandb.keras import WandbMetricsLogger
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import f1_score
from joblib import dump, load

from scaler import scaler
from deep_classifier import classifier

if __name__ == '__main__':
    run = wandb.init(project="classify_malware",group='rf_deep')
    print("Num GPUs Available: ", len(tf.config.list_physical_devices('GPU')))

    # seed = 123
    # random.seed(seed)
    # tf.random.set_seed(seed)
    # np.random.seed(seed)

    TRAIN_PATH = 'data/train_set.npz'
    VALID_PATH = 'data/validate_set.npz'
    TEST_PATH = 'data/test_set.npz'

    train_set = np.load(TRAIN_PATH)
    valid_set = np.load(VALID_PATH)
    test_set = np.load(TEST_PATH)

    X_train = train_set['x']
    y_train = train_set['y']

    X_valid = valid_set['x']
    y_valid = valid_set['y']

    X_test = test_set['x']
    y_test = test_set['y']

    X_train_preprocess, X_valid_preprocess, X_test_preprocess = scaler(X_train,X_test,X_valid)

    rf = RandomForestClassifier(n_jobs=-1, verbose=1)

    rf.fit(X_train_preprocess,y_train)

    selector = SelectFromModel(rf,prefit=True)

    selector.fit(X_train_preprocess,y_train)
    print(selector.estimator_)

    encoded_train = selector.transform(X_train_preprocess)
    encoded_valid = selector.transform(X_valid_preprocess)
    encoded_test = selector.transform(X_test_preprocess)

    print(f"X_train shape: {encoded_train.shape}")
    print(f"X_valid shape: {encoded_valid.shape}")
    print(f"X_test shape: {encoded_test.shape}")

    dump(selector, 'model/rf_deep_selector.joblib')

    # convert to tensor
    encoded_train = tf.convert_to_tensor(encoded_train,dtype=tf.float32)
    y_train = tf.convert_to_tensor(y_train,dtype=tf.int32)
    y_train = tf.reshape(y_train,[tf.shape(y_train)[0],1])

    encoded_valid = tf.convert_to_tensor(encoded_valid,dtype=tf.float32)
    y_valid = tf.convert_to_tensor(y_valid,dtype=tf.int32)
    y_valid = tf.reshape(y_valid,[tf.shape(y_valid)[0],1])

    encoded_test = tf.convert_to_tensor(encoded_test,dtype=tf.float32)
    y_test = tf.convert_to_tensor(y_test,dtype=tf.int32)
    y_test = tf.reshape(y_test,[tf.shape(y_test)[0],1])

    model = classifier(no_features=encoded_train.shape[1])

    # callback for classifier
    reduce_lr = keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.2,patience=15, min_lr=0.00005,verbose=1)

    callback_list = [reduce_lr, WandbMetricsLogger(log_freq='epoch')]

    history = model.fit(encoded_train, y_train,
            epochs = 50,
            batch_size = 512,
            validation_data = (encoded_valid , y_valid ),
            shuffle = True, verbose = 2, callbacks = callback_list
            )
    
    precision = keras.metrics.Precision(name = 'Precision')
    recall = keras.metrics.Recall(name = 'Recall')
    false_neg = keras.metrics.FalseNegatives(name = 'FalseNegative')
    false_pos = keras.metrics.FalsePositives(name = 'FalsePositive')

    predict = model.predict(encoded_test)

    test_result = model.evaluate(encoded_test,y_test)

    precision.update_state(y_pred=predict,y_true=y_test)
    recall.update_state(y_pred=predict,y_true=y_test)
    false_neg.update_state(y_pred=predict,y_true=y_test)
    false_pos.update_state(y_pred=predict,y_true=y_test)

    print(f'{model.metrics_names}: {test_result}')

    wandb.log({'test_bi_cross_entropy':test_result[0],
            'binary_accuracy':test_result[1],
            'precision':precision.result(),
            'recall':recall.result(),
            'f1':f1_score(y_test, np.where(predict > 0.5, 1,0), average='binary'),
            'false_negative_rate':false_neg.result(),
            'false_positive_rate':false_pos.result(),
            'n_features':np.size(encoded_train,1)
            })
    run.finish()
    model.save_weights('model/rf_classifier_weight.weights.h5',overwrite=True)