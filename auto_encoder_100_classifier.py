import numpy as np
import tensorflow as tf
import keras
import random
import matplotlib.pyplot as plt
import wandb
from wandb.keras import WandbMetricsLogger
from sklearn.metrics import f1_score

from scaler import scaler
from auto_encoder_100 import DeepAE

def classifier():
    model = keras.Sequential([ 
        keras.layers.Dense(128, activation='relu'),
        keras.layers.BatchNormalization(),
        keras.layers.Dropout(0.5),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.BatchNormalization(),
        keras.layers.Dense(32, activation='relu'),
        keras.layers.BatchNormalization(),
        keras.layers.Dense(16, activation='relu'),
        keras.layers.BatchNormalization(),
        keras.layers.Dropout(0.5),
        keras.layers.Dense(1, activation='sigmoid')
    ])
    model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.0001), loss=keras.losses.BinaryCrossentropy(),
                  metrics = [
                      keras.metrics.BinaryAccuracy(name = 'Binary Accuracy'),
                      ])
    return model

if __name__ == '__main__':
    run = wandb.init(project="classify_malware",group='ae_100')
    print("Num GPUs Available: ", len(tf.config.list_physical_devices('GPU')))

    # seed = 123
    # random.seed(seed)
    # tf.random.set_seed(seed)
    # np.random.seed(seed)

    TRAIN_PATH = 'data/train_set.npz'
    VALID_PATH = 'data/validate_set.npz'
    TEST_PATH = 'data/test_set.npz'

    train_set = np.load(TRAIN_PATH)
    valid_set = np.load(VALID_PATH)
    test_set = np.load(TEST_PATH)

    X_train = train_set['x']
    y_train = train_set['y']

    X_valid = valid_set['x']
    y_valid = valid_set['y']

    X_test = test_set['x']
    y_test = test_set['y']

    X_train_preprocess, X_valid_preprocess, X_test_preprocess = scaler(X_train,X_test,X_valid)

    # convert to tensor
    X_train_preprocess = tf.convert_to_tensor(X_train_preprocess,dtype=tf.float32)
    y_train = tf.convert_to_tensor(y_train,dtype=tf.int32)
    y_train = tf.reshape(y_train,[tf.shape(y_train)[0],1])

    X_valid_preprocess = tf.convert_to_tensor(X_valid_preprocess,dtype=tf.float32)
    y_valid = tf.convert_to_tensor(y_valid,dtype=tf.int32)
    y_valid = tf.reshape(y_valid,[tf.shape(y_valid)[0],1])

    X_test_preprocess = tf.convert_to_tensor(X_test_preprocess,dtype=tf.float32)
    y_test = tf.convert_to_tensor(y_test,dtype=tf.int32)
    y_test = tf.reshape(y_test,[tf.shape(y_test)[0],1])


    ae = keras.models.load_model('model/ae_100.keras',custom_objects={"DeepAE": DeepAE})

    encoded_train = ae.encoder(X_train_preprocess)
    encoded_valid = ae.encoder(X_valid_preprocess)
    encoded_test = ae.encoder(X_test_preprocess)

    model = classifier()

    # callback
    reduce_lr = keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.2,patience=15, min_lr=0.00005,verbose=1)

    callback_list = [reduce_lr, WandbMetricsLogger(log_freq='epoch')]

    history = model.fit(encoded_train, y_train,
            epochs = 50,
            batch_size = 512,
            validation_data = (encoded_valid , y_valid ),
            shuffle = True, verbose = 2, callbacks = callback_list
            )

    precision = keras.metrics.Precision(name = 'Precision')
    recall = keras.metrics.Recall(name = 'Recall')
    false_neg = keras.metrics.FalseNegatives(name = 'FalseNegative')

    predict = model.predict(encoded_test)

    test_result = model.evaluate(encoded_test,y_test)

    precision.update_state(y_pred=predict,y_true=y_test)
    recall.update_state(y_pred=predict,y_true=y_test)
    false_neg.update_state(y_pred=predict,y_true=y_test)

    print(f'{model.metrics_names}: {test_result}')

    wandb.log({'test_bi_cross_entropy':test_result[0],
            'binary_accuracy':test_result[1],
            'precision':precision.result(),
            'recall':recall.result(),
            'f1':f1_score(y_test, np.where(predict > 0.5, 1,0), average='binary'),
            'false_negative_rate':false_neg.result()
            })
    run.finish()
    model.save('model/ae_100_classifier.keras')